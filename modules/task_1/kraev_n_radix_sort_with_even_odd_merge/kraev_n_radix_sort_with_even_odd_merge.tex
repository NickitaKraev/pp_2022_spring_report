\documentclass{report}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{luainputenc}
\usepackage[english, russian]{babel}
\usepackage[pdftex]{hyperref}
\usepackage[14pt]{extsizes}
\usepackage{color}
\usepackage{geometry}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{indentfirst}

\usepackage{listings}
\usepackage{xcolor}

%New colors defined below
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

%Code listing style named "mystyle"
\lstdefinestyle{mystyle}{
  backgroundcolor=\color{backcolour},   commentstyle=\color{codegreen},
  keywordstyle=\color{magenta},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codepurple},
  basicstyle=\ttfamily\footnotesize,
  breakatwhitespace=false,         
  breaklines=true,                 
  captionpos=b,                    
  keepspaces=true,                 
  numbers=left,                    
  numbersep=5pt,                  
  showspaces=false,                
  showstringspaces=false,
  showtabs=false,                  
  tabsize=2
}

%"mystyle" code listing set
\lstset{style=mystyle}

\geometry{a4paper,top=2cm,bottom=3cm,left=2cm,right=1.5cm}
\setlength{\parskip}{0.5cm}
\setlist{nolistsep, itemsep=0.3cm,parsep=0pt}

\lstset{language=C++,
		basicstyle=\footnotesize,
		keywordstyle=\color{blue}\ttfamily,
		stringstyle=\color{red}\ttfamily,
		commentstyle=\color{green}\ttfamily,
		morecomment=[l][\color{magenta}]{\#}, 
		tabsize=4,
		breaklines=true,
  		breakatwhitespace=true,
  		title=\lstname,       
}

\makeatletter
\renewcommand\@biblabel[1]{#1.\hfil}
\makeatother

\begin{document}

\begin{titlepage}

\begin{center}
Министерство науки и высшего образования Российской Федерации
\end{center}

\begin{center}
Федеральное государственное автономное образовательное учреждение высшего образования \\
Национальный исследовательский Нижегородский государственный университет им. Н.И. Лобачевского
\end{center}

\begin{center}
Институт информационных технологий, математики и механики
\end{center}

\vspace{4em}

\begin{center}
\textbf{\LargeОтчет по лабораторной работе} \\
\end{center}
\begin{center}
\textbf{\Large«Поразрядная сортировка для вещественных чисел (тип double) с четно-нечетным слиянием Бэтчера»} \\
\end{center}

\vspace{4em}

\newbox{\lbox}
\savebox{\lbox}{\hbox{text}}
\newlength{\maxl}
\setlength{\maxl}{\wd\lbox}
\hfill\parbox{7cm}{
\hspace*{5cm}\hspace*{-5cm}\textbf{Выполнил:} \\ студент группы 381906-2 \\ Краев Н. С.\\
\\
\hspace*{5cm}\hspace*{-5cm}\textbf{Проверил:}\\ доцент кафедры МОСТ, \\ кандидат технических наук \\ Сысоев А. В.\\
}
\vspace{\fill}

\begin{center} Нижний Новгород \\ 2022 \end{center}

\end{titlepage}

\setcounter{page}{2}

% Содержание
\tableofcontents
\newpage

% Введение
\section*{Введение}
\addcontentsline{toc}{section}{Введение}
Сортировка - это процесс упорядочения некоторого множества элементов, на котором определены отношения порядка >, <, >=, <= (по возрастанию
или убыванию).
\par Алгоритмы сортировки имеют большое практическое применение. Их
можно встретить почти везде, где речь идет об обработке и хранении больших
объемов информации. Некоторые задачи обработки данных решаются проще,
если данные упорядочены. Сортировка применяется во всех без исключения областях программирования, например, базы данных или математические программы.
\par В данной лабораторной работе рассматривается алгоритм поразрядной сортировки для вещественных чисел с четно-нечетным слиянием Бэтчера, время работы которого является линейным.
\newpage

% Постановка задачи
\section*{Постановка задачи}
\addcontentsline{toc}{section}{Постановка задачи}
Необходимо реализовать последовательную и параллельную версию алгоритма поразрядной сортировки для вещественных чисел с четно-нечетным слиянием Бэтчера, проверить корректность их работы , провести эксперименты для оценки эффективности параллельной схемы. По полученным результатам сделать выводы.
\par Для реализации параллельных версий необходимо использовать стандарт OpenMP и библиотеку Intel TBB. Для проверки корректности работы алгоритмов использовать Google Testing Framework.
\newpage

% Описание алгоритма
\section*{Описание алгоритма}
\addcontentsline{toc}{section}{Описание алгоритма}
Сортировка проводится для упорядочения вещественных чисел (тип double), которые в памяти компьтера занимают 8 байт, следовательно в качестве разряда будет рассматриваться 1 байт вещественного числа, а в качестве ключа будет выступать значение байта, которое находится в диапазоне от 0 до 255 включительно.
\par В данной сортировке сравнение производится поразрядно: сначала сравниваются значения одного крайнего разряда, и элементы группируются по результатам этого сравнения, затем сравниваются значения следующего разряда, соседнего, и элементы либо упорядочиваются по результатам сравнения значений этого разряда внутри образованных на предыдущем проходе групп, либо переупорядочиваются в целом, но сохраняя относительный порядок, достигнутый при предыдущей сортировке. Затем аналогично делается для следующего разряда, и так до последнего байта. Все дело в том, что последний байт является «знаковым», то есть старший бит этого байта определяет знак числа, если бит принимает значение 0 - число положительное, если 1 - число отрицательное, в связи с этим при сортировке по последнему байту сначала по убыванию упорядочиваются байты из диапазона значений от 255 до 128 включительно, что обеспечивает корректную сортировку отрицательных чисел, затем по возрастанию упорядочиваются байты из диапазона значений от 0 до 127 включительно, что обеспечивает корректную сортировку нулей и положительных чисел.
\par Чётно-нечётное слияние Бэтчера заключается в том, что два упорядоченных массива, которые необходимо слить, разделяются на чётные и нечётные элементы.  Такое слияние может быть выполнено параллельно. Чтобы массив стал окончательно отсортированным, достаточно сравнить
пары элементов, стоящие на нечётной и чётной позициях. Первый и последний элементы массива проверять не надо, т.к. они являются минимальным и максимальным элементов массивов. 
\newpage

% Схема распараллеливания
\section*{Схема распараллеливания}
\addcontentsline{toc}{section}{Схема распараллеливания}
Для распараллеливания данного алгоритма нужно поделить исходный массив на подмассивы так, чтобы каждому потоку достался 1 подмассив, который он будет сортировать. После того как все подмассивы будут отсортированы, выполняется четно-нечетное слияние Бэтчера. 
\par Чётно-нечётное слияние Бэтчера позволяет задействовать 2 потока при
слиянии двух упорядоченных массивов. В этом случае слияние n массивов
могут выполнять n параллельных потоков. На следующем шаге слияние n/2
полученных массивов будут выполнять n/2 потоков и т.д. На последнем
шаге два массива будут сливать 2 потока. 
\par В реализованной параллельной версии с помощью стандарта OpenMP количество потоков задается пользователем, данные между потоками распределяются равномерно, для распараллеливания сортировки и слияния используется директива \#pragma omp parallel, также для слияния используется директива \#pragma omp barrier для того, чтобы обеспечить синхронизацию потоков.
\par В реализованной параллельной версии с помощью библиотеки Intel TBB, количество потоков задается пользователем, данные между потоками распределяются равномерно, для распараллеливания сортировки и слияния используется функция tbb::parallel\_for, которая принимает два аргумента: итерационное пространство и функтор. В качестве итерационного пространства выступает подмассив элементов, а в качестве функтора лямбда-функция, выполняющая поразрядную сортировку подмассива.
\par В реализации с помощью std::thread, количество потоков устанавливается автоматически, а для распараллеливания сортировки и слияния создается динамический массив из потоков. Каждому потоку на исполнение передается своя порция данных и функция сортировки, после чего с помощью метода join потоки синхронизируются и начинается этап четно-нечетного слияния.
\newpage

% Описание программной реализации
\section*{Описание программной реализации}
\addcontentsline{toc}{section}{Описание программной реализации}
Программа состоит из трех файлов: main.cpp, radix\_sort\_with\_even\_odd\_merge.h, radix\_sort\_with\_even\_odd\_merge.cpp. В radix\_sort\_with\_even\_odd\_merge.h находятся объявления функций, а в radix\_sort\_with\_even\_odd\_merge.cpp их реализация, в main.cpp содержатся тесты, которые проверяют корректность работы программы и ее производительность.
\par Функции программы:
\begin{lstlisting}
std::vector<double> getRandomVector(int size);
void radixSort(std::vector<double>* vec); 
std::vector<double> parallelRadixSort(std::vector<double>* vec,
    int number_threads, int size);
void evenOrOddSplitter(std::vector<double>* vec_1, std::vector<double>* vec_2,
    bool check);
std::vector<double> simpleComparator(std::vector<double>* vec_1,
    std::vector<double>* vec_2);
\end{lstlisting}
\par Функция getRandomVector - формирует вектор псевдослучайных вещественных чисел, который требуется отсортировать, radixSort - исполняет алгоритм поразрядной сортировки, evenOrOddSplitter - выполняет упорядочение четных или нечетных элементов, в зависимости от значения булевской переменной check,  simpleComparator - выполняет упорядочение четных и нечетных элементов между собой, проходя по вектору лишь один раз, parallelRadixSort - исполняет параллельный алгоритм поразрядной сортировки с четно-нечетным слиянием Бэтчера.
\newpage

% Подтверждение корректности
\section*{Подтверждение корректности}
\addcontentsline{toc}{section}{Подтверждение корректности}
Для подтверждения корректности в программе представлен набор тестов, разработанных с Google Testing Framework.
\par Набор представляет из себя тесты, которые проверяют корректность сортировки, а также эффективность работы параллельной версии.
\par Успешное прохождение всех тестов подтверждает корректность работы написанной программы.
\newpage

% Результаты экспериментов
\section*{Результаты экспериментов}
\addcontentsline{toc}{section}{Результаты экспериментов}
Эксперименты для оценки эффективности проводились на ПК со следующими характеристиками:

\begin{itemize}
\item Процессор: Intel Core i5-10210U, 1.60 GHz, 4 ядра, 4 логических процессора;
\item Оперативная память: 8 ГБ;
\item ОС: Microsoft Windows 10 Home.
\end{itemize}

\par Для проведения экспериментов производилась поразрядная сортировка для вещественных чисел (тип double) с четно-нечетным слиянием Бэтчера над миллионом элементов.

\begin{table}[!h]
\caption{Результаты экспериментов. Сравнение с OpenMP}
\centering
\begin{tabular}{lllll}
Число потоков & Последовательно & Параллельно & Ускорение \\
2 & 2,3765 & 1,29434 & 1,83608 \\
3 & 2,04255 & 1,396 & 1,46314 \\
4 & 1,75328 & 1,35253 & 1,29629 \\
8 & 1,80398 & 2,1269 & 0,848175
\end{tabular}
\end{table}

\begin{table}[!h]
\caption{Результаты экспериментов. Сравнение с TBB}
\centering
\begin{tabular}{lllll}
Число потоков & Последовательно & Параллельно & Ускорение \\
2 & 2,34214 & 1,15878 & 2,02122 \\
3 & 1,89304 & 1,10616 & 1,71137 \\
4 & 2,10444 & 1,43717 & 1,46429 \\
8 & 1,71208 & 2,72965 & 0,627217
\end{tabular}
\end{table}

\begin{table}[!h]
\caption{Результаты экспериментов. Сравнение с std::thread}
\centering
\begin{tabular}{lllll}
Число потоков & Последовательно & Параллельно & Ускорение \\
4 & 2,11999 & 1,05349 & 2,01234 \\
4 & 1,8879 & 1,139 & 1,65736
\end{tabular}
\end{table}

\par По данным, полученным в результате экспериментов, можно сделать вывод о том, что параллельный случай работает быстрее, чем последовательный, на небольшом количестве потоков. Это связано с тем, что при увеличении количества потоков увеличиваются накладные расходы, а также увеличивается количество слияний, что отрицательно влияет на эффективность программы.
\newpage

% Заключение
\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}
В ходе выполнения лабораторной работы были разработаны последовательная и параллельная реализации алгоритма поразрядной сортировки для вещественных чисел с четно-нечетным слиянием Бэтчера.
\par Задача работы была успешно достигнута, поскольку результаты проведенных экспериментов по оценке эффективности показывают, что параллельная реализация работает быстрее, чем последовательная.
\par Кроме того, были написаны тесты с использованием Google Testing Framework, необходимые для подтверждения корректности работы программы.
\newpage

% Список литературы
\begin{thebibliography}{1}
\addcontentsline{toc}{section}{Список литературы}
\item А.В. Сысоев, И.Б. Мееров, А.А. Сиднев «Лабораторная работа №7
Оптимизация вычислительно трудоемкого
программного модуля для архитектуры
Intel Xeon Phi. Линейные сортировки»  (дата обращения: 31.05.2021)
\item Якобовский М.В. Параллельные алгоритмы сортировки больших объемов данных. (дата обращения: 31.05.2021) \newline URL: \url {http://lira.imamod.ru/FondProgramm/Sort} 
\item Кнут Д. Искусство программирования, т.3. Сортировка и поиск. 2-е издание. – М.: Вильямс, 2009 . – 824 С.
\end{thebibliography}
\newpage

% Приложение
\section*{Приложение}
\addcontentsline{toc}{section}{Приложение}
\par 1. Последовательная реализация. Файл: radix\_sort\_with\_even\_odd\_merge.h
\begin{lstlisting}[language=C++]
// Copyright 2022 Kraev Nikita
#ifndef MODULES_TASK_1_KRAEV_N_RADIX_SORT_WITH_EVEN_ODD_MERGE_H_
#define MODULES_TASK_1_KRAEV_N_RADIX_SORT_WITH_EVEN_ODD_MERGE_H_
#include <iostream>
#include <vector>
#include <random>

std::vector<double> getRandomVector(int size);
void radixSort(std::vector<double>* vec);

#endif  // MODULES_TASK_1_KRAEV_N_RADIX_SORT_WITH_EVEN_ODD_MERGE_H_
\end{lstlisting}

\par 2. Последовательная реализация. Файл: radix\_sort\_with\_even\_odd\_merge.сpp

\begin{lstlisting}[language=C++]
// Copyright 2022 Kraev Nikita
#include "../../../modules/task_1/kraev_n_radix_sort_with_even_odd_merge.h"

std::vector<double> getRandomVector(int size) {
    std::vector<double> random_vec(size);

    std::random_device rd;
    std::default_random_engine generator(rd());
    double a = -5000.0, b = 5000.0;
    std::uniform_real_distribution<double> dis(a, b);

    for (int i = 0; i < size; ++i) {
        random_vec[i] = dis(generator);
    }

    return random_vec;
}

void radixSort(std::vector<double>* vec) {
    size_t size = vec->size();
    size_t local_size;
    int tmp;
    int j = 0;
    std::vector<std::vector<double>> counters(256);
    for (int index = 0; index < 7; index++) {
        for (size_t i = 0; i < size; i++) {
            tmp = static_cast<int>(*((unsigned char*)&(*vec)[i] + index));
            counters[tmp].push_back((*vec)[i]);
        }

        for (int i = 0; i < 256; i++) {
            if (!counters[i].empty()) {
                local_size = counters[i].size();
                for (size_t k = 0; k < local_size; k++) {
                    (*vec)[j] = counters[i][k];
                    ++j;
                }
                counters[i].clear();
            }
        }
        j = 0;
    }

    for (size_t i = 0; i < size; i++) {
        tmp = static_cast<int>(*((unsigned char*)&(*vec)[i] + 7));
        counters[tmp].push_back((*vec)[i]);
    }

    for (int i = 255; i >= 128; i--) {
        if (!counters[i].empty()) {
            local_size = counters[i].size();
            for (size_t k = local_size - 1; k >= 1; k--) {
                (*vec)[j] = counters[i][k];
                j++;
            }
            (*vec)[j] = counters[i][0];
            j++;
        }
    }

    for (int i = 0; i < 128; i++) {
        if (!counters[i].empty()) {
            local_size = counters[i].size();
            for (size_t k = 0; k < local_size; k++) {
                (*vec)[j] = counters[i][k];
                j++;
            }
        }
    }
}
\end{lstlisting}

\par 3. Последовательная реализация. Файл: main.cpp

\begin{lstlisting}[language=C++]
// Copyright 2022 Kraev Nikita
#include <gtest/gtest.h>
#include "./radix_sort_with_even_odd_merge.h"

TEST(Generate_Vector, Test_Generate_Random_Vector) {
    std::vector<double> random_vector = getRandomVector(100);
    ASSERT_TRUE(!random_vector.empty());
}

TEST(Sequential_Sort, Test_Radix_Sort_1) {
    std::vector<double> vec = { 1.0, -6.2, 7.45, -22.3457, 0.0, 45.69876, -0.03 };
    std::vector<double> sort_vec = { -22.3457, -6.2, -0.03, 0.0, 1.0, 7.45, 45.69876 };
    radixSort(&vec);
    ASSERT_EQ(sort_vec, vec);
}

TEST(Sequential_Sort, Test_Radix_Sort_2) {
    std::vector<double> random_vector = getRandomVector(100);
    std::vector<double> result_vector = random_vector;
    radixSort(&random_vector);
    std::sort(result_vector.begin(), result_vector.end());
    ASSERT_EQ(result_vector, random_vector);
}

TEST(Sequential_Sort, Test_Normal_Size_Vector) {
    std::vector<double> random_vector = getRandomVector(10000);
    std::vector<double> result_vector = random_vector;
    radixSort(&random_vector);
    std::sort(result_vector.begin(), result_vector.end());
    ASSERT_EQ(result_vector, random_vector);
}

TEST(Sequential_Sort, Test_Big_Size_Vector) {
    std::vector<double> random_vector = getRandomVector(100000);
    std::vector<double> result_vector = random_vector;
    radixSort(&random_vector);
    std::sort(result_vector.begin(), result_vector.end());
    ASSERT_EQ(result_vector, random_vector);
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
\end{lstlisting}

\par 4. Реализация на OpenMP. Файл: radix\_sort\_with\_even\_odd\_merge\_omp.h

\begin{lstlisting}[language=C++]
// Copyright 2022 Kraev Nikita
#ifndef MODULES_TASK_2_KRAEV_N_RADIX_SORT_WITH_EVEN_ODD_MERGE_H_
#define MODULES_TASK_2_KRAEV_N_RADIX_SORT_WITH_EVEN_ODD_MERGE_H_
#include <omp.h>
#include <vector>
#include <random>

void radixSort(std::vector<double>* vec, size_t left, size_t right);
std::vector<double> getRandomVector(int size);
void evenOrOddSplitter(std::vector<double>* vec, size_t left_1, size_t right_1, size_t left_2, size_t right_2, bool check);
void simpleComparator(std::vector<double>* vec, size_t left, size_t right);
int findNumberPhaseMerge(int size);
void parallelRadixSort(std::vector<double>* vec, int number_threads, int size);

#endif  // MODULES_TASK_2_KRAEV_N_RADIX_SORT_WITH_EVEN_ODD_MERGE_H_
\end{lstlisting}

\par 5. Реализация на OpenMP. Файл: radix\_sort\_with\_even\_odd\_merge\_omp.cpp

\begin{lstlisting}[language=C++]
// Copyright 2022 Kraev Nikita
#include "../../../modules/task_2/radix_sort_with_even_odd_merge.h"

void radixSort(std::vector<double>* vec, size_t left, size_t right) {
	size_t local_size;
	int tmp;
	int j = left;
	std::vector<std::vector<double>> counters(256);
	for (int index = 0; index < 7; index++) {
		for (size_t i = left; i < right; i++) {
			tmp = static_cast<int>(*((unsigned char*)&(*vec)[i] + index));
			counters[tmp].push_back((*vec)[i]);
		}

		for (int i = 0; i < 256; i++) {
			if (!counters[i].empty()) {
				local_size = counters[i].size();
				for (size_t k = 0; k < local_size; k++) {
					(*vec)[j] = counters[i][k];
					++j;
				}
				counters[i].clear();
			}
		}
		j = left;
	}

	for (size_t i = left; i < right; i++) {
		tmp = static_cast<int>(*((unsigned char*)&(*vec)[i] + 7));
		counters[tmp].push_back((*vec)[i]);
	}

	for (int i = 255; i >= 128; i--) {
		if (!counters[i].empty()) {
			local_size = counters[i].size();
			for (size_t k = local_size - 1; k >= 1; k--) {
				(*vec)[j] = counters[i][k];
				j++;
			}
			(*vec)[j] = counters[i][0];
			j++;
		}
	}

	for (int i = 0; i < 128; i++) {
		if (!counters[i].empty()) {
			local_size = counters[i].size();
			for (size_t k = 0; k < local_size; k++) {
				(*vec)[j] = counters[i][k];
				j++;
			}
		}
	}
}

std::vector<double> getRandomVector(int size) {
	std::vector<double> random_vec(size);
	std::random_device rd;
	std::default_random_engine generator(rd());
	double a = -5000.0, b = 5000.0;
	std::uniform_real_distribution<double> dis(a, b);

	for (int i = 0; i < size; ++i) {
		random_vec[i] = dis(generator);
	}

	return random_vec;
}

void evenOrOddSplitter(std::vector<double>* vec, size_t left_1, size_t right_1,
	size_t left_2, size_t right_2, bool check) {
	size_t a, b;
	if (check)
		a = left_1, b = left_2;
	else
		a = left_1 + 1, b = left_2 + 1;

	std::vector<double> tmp;

	while (a < right_1 && b < right_2) {
		if ((*vec)[a] < (*vec)[b]) {
			tmp.push_back((*vec)[a]);
			a += 2;
		}
		else {
			tmp.push_back((*vec)[b]);
			b += 2;
		}
	}

	if (a >= right_1) {
		for (size_t j = b; j < right_2; j += 2) {
			tmp.push_back((*vec)[j]);
		}
	}
	else {
		for (size_t j = a; j < right_1; j += 2) {
			tmp.push_back((*vec)[j]);
		}
	}

	if (check)
		a = left_1, b = left_2;
	else
		a = left_1 + 1, b = left_2 + 1;

	size_t i = 0;

	while (a < right_1) {
		(*vec)[a] = tmp[i];
		a += 2;
		i++;
	}

	while (b < right_2) {
		(*vec)[b] = tmp[i];
		b += 2;
		i++;
	}
}

void simpleComparator(std::vector<double>* vec, size_t left, size_t right) {
	for (size_t i = left; i < right - 1; i++) {
		if ((*vec)[i] > (*vec)[i + 1]) std::swap((*vec)[i], (*vec)[i + 1]);
	}
}

int findNumberPhaseMerge(int size) {
	int k = 1;
	while (size > std::pow(2, k)) {
		k++;
	}
	return k;
}

void parallelRadixSort(std::vector<double>* vec, int number_threads, int size) {
	int local_size = size / number_threads;
	int remainder = size % number_threads;
	std::vector<int> begin(number_threads);
	std::vector<int> end(number_threads);
	int k = findNumberPhaseMerge(number_threads);
	int thread_id;

	begin[0] = 0;
	end[0] = local_size + remainder;
	for (int i = 1; i < number_threads; i++) {
		begin[i] = end[0] + local_size * (i - 1);
		end[i] = begin[i] + local_size;
	}

	omp_set_num_threads(number_threads);

	#pragma omp parallel private(thread_id)
	{
		thread_id = omp_get_thread_num();
		radixSort(vec, begin[thread_id], end[thread_id]);
		#pragma omp barrier
	}

	for (int i = 0; i < k; i++) {
		omp_set_num_threads(number_threads);
		#pragma omp parallel private(thread_id)
		{
			thread_id = omp_get_thread_num();
			if (thread_id % 2 == 0 && thread_id + 1 < number_threads) {
				evenOrOddSplitter(vec, begin[thread_id], end[thread_id],
					begin[thread_id + 1], end[thread_id + 1], true);
			}
			else if (thread_id % 2 == 1) {
				evenOrOddSplitter(vec, begin[thread_id - 1], end[thread_id - 1],
					begin[thread_id], end[thread_id], false);
			}

			#pragma omp barrier

			if (thread_id % 2 == 0 && thread_id + 1 < number_threads) {
				simpleComparator(vec, begin[thread_id], end[thread_id]);
			}
			else if (thread_id % 2 == 1) {
				simpleComparator(vec, begin[thread_id] - 1, end[thread_id]);
			}

			#pragma omp barrier

			#pragma omp master
			{
				for (int j = 0; j < number_threads - 1; j += 2) {
					begin[j / 2] = begin[j];
					end[j / 2] = end[j + 1];
				}
				if (number_threads % 2 == 1) {
					begin[(number_threads - 1) / 2] = begin[number_threads - 1];
					end[(number_threads - 1) / 2] = end[number_threads - 1];
					number_threads = number_threads / 2 + 1;
				}
				else {
					number_threads /= 2;
				}
			}
			#pragma omp barrier
		}
	}
}
\end{lstlisting}

\par 6. Реализация на OpenMP. Файл: main.cpp

\begin{lstlisting}[language=C++]
// Copyright 2022 Kraev Nikita
#include <gtest/gtest.h>
#include "./radix_sort_with_even_odd_merge.h"

TEST(Sequential_Sort, Test_Radix_Sort_1) {
    std::vector<double> vec = { 1.0, -6.2, 7.45, -22.3457, 0.0, 45.69876, -0.03 };
    std::vector<double> sort_vec = { -22.3457, -6.2, -0.03, 0.0, 1.0, 7.45, 45.69876 };
    radixSort(&vec, 0, vec.size());
    ASSERT_EQ(sort_vec, vec);
}

TEST(Parallel_Sort, Test_Radix_Sort_2) {
    std::vector<double> vec = { 1.0, -6.2, 7.45, -22.3457, 0.0, 45.69876, -0.03 };
    std::vector<double> sort_vec = { -22.3457, -6.2, -0.03, 0.0, 1.0, 7.45, 45.69876 };
    int number_threads = 2;
    parallelRadixSort(&vec, number_threads, vec.size());
    ASSERT_EQ(sort_vec, vec);
}

TEST(Parallel_Sort, Test_Radix_Sort_3) {
    int size = 100;
    std::vector<double> vec = getRandomVector(size);
    std::vector<double> std_sort_vec = vec;
    int number_threads = 2;
    std::sort(std_sort_vec.begin(), std_sort_vec.end());
    parallelRadixSort(&vec, number_threads, vec.size());
    ASSERT_EQ(std_sort_vec, vec);
}

TEST(Parallel_Sort, Test_Radix_Sort_4) {
    int size = 1000000;
    std::vector<double> vec = getRandomVector(size);
    std::vector<double> seq_vec = vec;
    int number_threads = 2;
    double begin_1 = omp_get_wtime();
    radixSort(&seq_vec, 0, seq_vec.size());
    double end_1 = omp_get_wtime();
    double time_1 = end_1 - begin_1;
    std::cout << time_1 << std::endl;
    double begin_2 = omp_get_wtime();
    parallelRadixSort(&vec, number_threads, vec.size());
    double end_2 = omp_get_wtime();
    double time_2 = end_2 - begin_2;
    std::cout << time_2 << std::endl;
    std::cout << "Boost:" << time_1 / time_2 << std::endl;
    ASSERT_EQ(seq_vec, vec);
}

TEST(Parallel_Sort, Test_Radix_Sort_5) {
    int size = 1000000;
    std::vector<double> vec = getRandomVector(size);
    std::vector<double> seq_vec = vec;
    int number_threads = 3;
    double begin_1 = omp_get_wtime();
    radixSort(&seq_vec, 0, seq_vec.size());
    double end_1 = omp_get_wtime();
    double time_1 = end_1 - begin_1;
    std::cout << time_1 << std::endl;
    double begin_2 = omp_get_wtime();
    parallelRadixSort(&vec, number_threads, vec.size());
    double end_2 = omp_get_wtime();
    double time_2 = end_2 - begin_2;
    std::cout << time_2 << std::endl;
    std::cout << "Boost:" << time_1 / time_2 << std::endl;
    ASSERT_EQ(seq_vec, vec);
}

TEST(Parallel_Sort, Test_Radix_Sort_6) {
    int size = 1000000;
    std::vector<double> vec = getRandomVector(size);
    std::vector<double> seq_vec = vec;
    int number_threads = 4;
    double begin_1 = omp_get_wtime();
    radixSort(&seq_vec, 0, seq_vec.size());
    double end_1 = omp_get_wtime();
    double time_1 = end_1 - begin_1;
    std::cout << time_1 << std::endl;
    double begin_2 = omp_get_wtime();
    parallelRadixSort(&vec, number_threads, vec.size());
    double end_2 = omp_get_wtime();
    double time_2 = end_2 - begin_2;
    std::cout << time_2 << std::endl;
    std::cout << "Boost:" << time_1 / time_2 << std::endl;
}

TEST(Parallel_Sort, Test_Radix_Sort_7) {
    int size = 1000000;
    std::vector<double> vec = getRandomVector(size);
    std::vector<double> seq_vec = vec;
    int number_threads = 8;
    double begin_1 = omp_get_wtime();
    radixSort(&seq_vec, 0, seq_vec.size());
    double end_1 = omp_get_wtime();
    double time_1 = end_1 - begin_1;
    std::cout << time_1 << std::endl;
    double begin_2 = omp_get_wtime();
    parallelRadixSort(&vec, number_threads, vec.size());
    double end_2 = omp_get_wtime();
    double time_2 = end_2 - begin_2;
    std::cout << time_2 << std::endl;
    std::cout << "Boost:" << time_1 / time_2 << std::endl;
}

int main(int argc, char **argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
\end{lstlisting}

\par 7. Реализация на TBB. Файл: radix\_sort\_with\_even\_odd\_merge\_tbb.h

\begin{lstlisting}[language=C++]
// Copyright 2022 Kraev Nikita
#ifndef MODULES_TASK_3_KRAEV_N_RADIX_SORT_WITH_EVEN_ODD_MERGE_TBB_H_
#define MODULES_TASK_3_KRAEV_N_RADIX_SORT_WITH_EVEN_ODD_MERGE_TBB_H_

#include <tbb/tbb.h>
#include <vector>
#include <random>
#include <omp.h>

std::vector<double> getRandomVector(int size);
void radixSort(std::vector<double>* vec);
std::vector<double> parallelRadixSort(std::vector<double>* vec,
    int number_threads, int size);
void evenOrOddSplitter(std::vector<double>* vec_1, std::vector<double>* vec_2,
    bool check);
std::vector<double> simpleComparator(std::vector<double>* vec_1,
    std::vector<double>* vec_2);
std::vector<double> batcherMerge(std::vector<double>* vec_1,
    std::vector<double>* vec_2);
#endif  // MODULES_TASK_3_KRAEV_N_RADIX_SORT_WITH_EVEN_ODD_MERGE_TBB_H_
\end{lstlisting}

\par 8. Реализация на TBB. Файл: radix\_sort\_with\_even\_odd\_merge\_tbb.cpp

\begin{lstlisting}[language=C++]
// Copyright 2022 Kraev Nikita
#include "../../../modules/task_3/kraev_n_radix_sort_with_even_odd_merge_tbb.h"

std::vector<double> getRandomVector(int size) {
	std::vector<double> random_vec(size);

	std::random_device rd;
	std::default_random_engine generator(rd());
	double a = -5000.0, b = 5000.0;
	std::uniform_real_distribution<double> dis(a, b);

	for (int i = 0; i < size; ++i) {
		random_vec[i] = dis(generator);
	}

	return random_vec;
}

void radixSort(std::vector<double>* vec) {
	size_t size = vec->size();
	size_t local_size;
	int tmp;
	int j = 0;
	std::vector<std::vector<double>> counters(256);
	for (int index = 0; index < 7; index++) {
		for (size_t i = 0; i < size; i++) {
			tmp = static_cast<int>(*((unsigned char*)&(*vec)[i] + index));
			counters[tmp].push_back((*vec)[i]);
		}

		for (int i = 0; i < 256; i++) {
			if (!counters[i].empty()) {
				local_size = counters[i].size();
				for (size_t k = 0; k < local_size; k++) {
					(*vec)[j] = counters[i][k];
					++j;
				}
				counters[i].clear();
			}
		}
		j = 0;
	}

	for (size_t i = 0; i < size; i++) {
		tmp = static_cast<int>(*((unsigned char*)&(*vec)[i] + 7));
		counters[tmp].push_back((*vec)[i]);
	}

	for (int i = 255; i >= 128; i--) {
		if (!counters[i].empty()) {
			local_size = counters[i].size();
			for (size_t k = local_size - 1; k >= 1; k--) {
				(*vec)[j] = counters[i][k];
				j++;
			}
			(*vec)[j] = counters[i][0];
			j++;
		}
	}

	for (int i = 0; i < 128; i++) {
		if (!counters[i].empty()) {
			local_size = counters[i].size();
			for (size_t k = 0; k < local_size; k++) {
				(*vec)[j] = counters[i][k];
				j++;
			}
		}
	}
}

void evenOrOddSplitter(std::vector<double>* vec_1, std::vector<double>* vec_2,
	bool check) {
	size_t a, b;
	size_t size_1 = vec_1->size(), size_2 = vec_2->size();
	if (check)
		a = 0, b = 0;
	else
		a = 1, b = 1;

	std::vector<double> tmp;

	while (a < size_1 && b < size_2) {
		if ((*vec_1)[a] < (*vec_2)[b]) {
			tmp.push_back((*vec_1)[a]);
			a += 2;
		}
		else {
			tmp.push_back((*vec_2)[b]);
			b += 2;
		}
	}

	if (a >= size_1) {
		for (size_t j = b; j < size_2; j += 2) {
			tmp.push_back((*vec_2)[j]);
		}
	}
	else {
		for (size_t j = a; j < size_1; j += 2) {
			tmp.push_back((*vec_1)[j]);
		}
	}

	if (check)
		a = 0, b = 0;
	else
		a = 1, b = 1;

	size_t i = 0;

	while (a < size_1) {
		(*vec_1)[a] = tmp[i];
		a += 2;
		i++;
	}

	while (b < size_2) {
		(*vec_2)[b] = tmp[i];
		b += 2;
		i++;
	}
}

std::vector<double> simpleComparator(std::vector<double>* vec_1,
	std::vector<double>* vec_2) {
	size_t size_1 = vec_1->size(), size_2 = vec_2->size();
	std::vector<double> result(size_1 + size_2);
	size_t j = 0;
	for (size_t i = 0; i < size_1 - 1; i++) {
		if ((*vec_1)[i] > (*vec_1)[i + 1]) {
			std::swap((*vec_1)[i], (*vec_1)[i + 1]);
		}
		result[j++] = (*vec_1)[i];
	}
	result[j++] = (*vec_1)[size_1 - 1];

	if ((*vec_1)[size_1 - 1] > (*vec_2)[0]) {
		result[j - 1] = (*vec_2)[0];
		(*vec_2)[0] = (*vec_1)[size_1 - 1];
	}
	for (size_t i = 0; i < size_2 - 1; i++) {
		if ((*vec_2)[i] > (*vec_2)[i + 1]) {
			std::swap((*vec_2)[i], (*vec_2)[i + 1]);
		}
		result[j++] = (*vec_2)[i];
	}
	result[j] = (*vec_2)[size_2 - 1];

	return result;
}

std::vector<double> batcherMerge(std::vector<double>* vec_1,
	std::vector<double>* vec_2) {
	evenOrOddSplitter(vec_1, vec_2, true);
	evenOrOddSplitter(vec_1, vec_2, false);
	return simpleComparator(vec_1, vec_2);
}

std::vector<double> parallelRadixSort(std::vector<double>* vec,
	int number_threads, int size) {
	int local_size = size / number_threads;
	int remainder = size % number_threads;
	std::vector<std::vector<double>> data(number_threads);
	data[0] = { vec->begin(), vec->begin() + local_size + remainder };
	for (int i = 1; i < number_threads; i++) {
		data[i] = { vec->begin() + local_size * i + remainder,
				   vec->begin() + local_size * (i + 1) + remainder };
	}

	tbb::task_scheduler_init init(number_threads);
	tbb::parallel_for(tbb::blocked_range<size_t>(0, data.size(), 1),
		[&data](const tbb::blocked_range<size_t>& range) {
			size_t begin = range.begin(), end = range.end();
			for (size_t i = begin; i != end; ++i) radixSort(&data[i]);
		},
		tbb::auto_partitioner());
	init.terminate();

	for (int i = 1; i < number_threads; i++) {
		data[0] = batcherMerge(&data[0], &data[i]);
	}

	return data[0];
}
\end{lstlisting}

\par 9. Реализация на TBB. Файл: main.cpp

\begin{lstlisting}[language=C++]
// Copyright 2022 Kraev Nikita
#include <gtest/gtest.h>
#include "./radix_sort_with_even_odd_merge_tbb.h"

TEST(Parallel_Sort, Test_Radix_Sort_1) {
    std::vector<double> vec = { 1.0, -6.2, 7.45, -22.3457, 0.0, 45.69876, -0.03 };
    std::vector<double> sort_vec = { -22.3457, -6.2, -0.03, 0.0, 1.0, 7.45, 45.69876 };
    int number_threads = 2;
    int size = 7;
    vec = parallelRadixSort(&vec, number_threads, size);
    ASSERT_EQ(sort_vec, vec);
}

TEST(Parallel_Sort, Test_Radix_Sort_2) {
    int size = 100;
    std::vector<double> vec = getRandomVector(size);
    std::vector<double> std_sort_vec = vec;
    int number_threads = 2;
    std::sort(std_sort_vec.begin(), std_sort_vec.end());
    vec = parallelRadixSort(&vec, number_threads, size);
    ASSERT_EQ(std_sort_vec, vec);
}

TEST(Parallel_Sort, Test_Radix_Sort_3) {
    int size = 1000000;
    std::vector<double> vec = getRandomVector(size);
    std::vector<double> seq_vec = vec;
    int number_threads = 2;
    double begin_1 = omp_get_wtime();
    radixSort(&seq_vec);
    double end_1 = omp_get_wtime();
    double time_1 = end_1 - begin_1;
    std::cout << time_1 << std::endl;
    double begin_2 = omp_get_wtime();
    vec = parallelRadixSort(&vec, number_threads, size);
    double end_2 = omp_get_wtime();
    double time_2 = end_2 - begin_2;
    std::cout << time_2 << std::endl;
    std::cout << "Boost:" << time_1 / time_2 << std::endl;
    ASSERT_EQ(seq_vec, vec);
}

TEST(Parallel_Sort, Test_Radix_Sort_4) {
    int size = 1000000;
    std::vector<double> vec = getRandomVector(size);
    std::vector<double> seq_vec = vec;
    int number_threads = 3;
    double begin_1 = omp_get_wtime();
    radixSort(&seq_vec);
    double end_1 = omp_get_wtime();
    double time_1 = end_1 - begin_1;
    std::cout << time_1 << std::endl;
    double begin_2 = omp_get_wtime();
    vec = parallelRadixSort(&vec, number_threads, size);
    double end_2 = omp_get_wtime();
    double time_2 = end_2 - begin_2;
    std::cout << time_2 << std::endl;
    std::cout << "Boost:" << time_1 / time_2 << std::endl;
    ASSERT_EQ(seq_vec, vec);
}

TEST(Parallel_Sort, Test_Radix_Sort_5) {
    int size = 1000000;
    std::vector<double> vec = getRandomVector(size);
    std::vector<double> seq_vec = vec;
    int number_threads = 4;
    double begin_1 = omp_get_wtime();
    radixSort(&seq_vec);
    double end_1 = omp_get_wtime();
    double time_1 = end_1 - begin_1;
    std::cout << time_1 << std::endl;
    double begin_2 = omp_get_wtime();
    vec = parallelRadixSort(&vec, number_threads, size);
    double end_2 = omp_get_wtime();
    double time_2 = end_2 - begin_2;
    std::cout << time_2 << std::endl;
    std::cout << "Boost:" << time_1 / time_2 << std::endl;
    ASSERT_EQ(seq_vec, vec);
}

TEST(Parallel_Sort, Test_Radix_Sort_6) {
    int size = 1000000;
    std::vector<double> vec = getRandomVector(size);
    std::vector<double> seq_vec = vec;
    int number_threads = 8;
    double begin_1 = omp_get_wtime();
    radixSort(&seq_vec);
    double end_1 = omp_get_wtime();
    double time_1 = end_1 - begin_1;
    std::cout << time_1 << std::endl;
    double begin_2 = omp_get_wtime();
    vec = parallelRadixSort(&vec, number_threads, size);
    double end_2 = omp_get_wtime();
    double time_2 = end_2 - begin_2;
    std::cout << time_2 << std::endl;
    std::cout << "Boost:" << time_1 / time_2 << std::endl;
    ASSERT_EQ(seq_vec, vec);
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
\end{lstlisting}

\par 10. Реализация на std::thread. Файл: radix\_sort\_with\_even\_odd\_merge\_std.h

\begin{lstlisting}[language=C++]
// Copyright 2022 Kraev Nikita
#ifndef MODULES_TASK_4_KRAEV_N_RADIX_SORT_WITH_EVEN_ODD_MERGE_STD_H_
#define MODULES_TASK_4_KRAEV_N_RADIX_SORT_WITH_EVEN_ODD_MERGE_STD_H_

#include <omp.h>
#include <vector>
#include <random>

std::vector<double> getRandomVector(int size);
void radixSort(std::vector<double>* vec);
std::vector<double> parallelRadixSort(std::vector<double>* vec,
    int number_threads, int size);
void evenOrOddSplitter(std::vector<double>* vec_1, std::vector<double>* vec_2,
    bool check);
std::vector<double> simpleComparator(std::vector<double>* vec_1,
    std::vector<double>* vec_2);
std::vector<double> batcherMerge(std::vector<double>* vec_1,
    std::vector<double>* vec_2);
std::vector<double> parallelRadixSort(std::vector<double>* vec, int size);

#endif  // MODULES_TASK_4_KRAEV_N_RADIX_SORT_WITH_EVEN_ODD_MERGE_STD_H_
\end{lstlisting}

\par 11. Реализация на std::thread. Файл: radix\_sort\_with\_even\_odd\_merge\_std.cpp

\begin{lstlisting}[language=C++]
// Copyright 2022 Kraev Nikita
#include "../../../modules/task_4/radix_sort_with_even_odd_merge_std.h"
#include "../../../3rdparty/unapproved/unapproved.h"

std::vector<double> getRandomVector(int size) {
    std::vector<double> random_vec(size);

    std::random_device rd;
    std::default_random_engine generator(rd());
    double a = -5000.0, b = 5000.0;
    std::uniform_real_distribution<double> dis(a, b);

    for (int i = 0; i < size; ++i) {
        random_vec[i] = dis(generator);
    }

    return random_vec;
}

void radixSort(std::vector<double>* vec) {
    size_t size = vec->size();
    size_t local_size;
    int tmp;
    int j = 0;
    std::vector<std::vector<double>> counters(256);
    for (int index = 0; index < 7; index++) {
        for (size_t i = 0; i < size; i++) {
            tmp = static_cast<int>(*((unsigned char*)&(*vec)[i] + index));
            counters[tmp].push_back((*vec)[i]);
        }

        for (int i = 0; i < 256; i++) {
            if (!counters[i].empty()) {
                local_size = counters[i].size();
                for (size_t k = 0; k < local_size; k++) {
                    (*vec)[j] = counters[i][k];
                    ++j;
                }
                counters[i].clear();
            }
        }
        j = 0;
    }

    for (size_t i = 0; i < size; i++) {
        tmp = static_cast<int>(*((unsigned char*)&(*vec)[i] + 7));
        counters[tmp].push_back((*vec)[i]);
    }

    for (int i = 255; i >= 128; i--) {
        if (!counters[i].empty()) {
            local_size = counters[i].size();
            for (size_t k = local_size - 1; k >= 1; k--) {
                (*vec)[j] = counters[i][k];
                j++;
            }
            (*vec)[j] = counters[i][0];
            j++;
        }
    }

    for (int i = 0; i < 128; i++) {
        if (!counters[i].empty()) {
            local_size = counters[i].size();
            for (size_t k = 0; k < local_size; k++) {
                (*vec)[j] = counters[i][k];
                j++;
            }
        }
    }
}

void evenOrOddSplitter(std::vector<double>* vec_1, std::vector<double>* vec_2,
    bool check) {
    size_t a, b;
    size_t size_1 = vec_1->size(), size_2 = vec_2->size();
    if (check)
        a = 0, b = 0;
    else
        a = 1, b = 1;

    std::vector<double> tmp;

    while (a < size_1 && b < size_2) {
        if ((*vec_1)[a] < (*vec_2)[b]) {
            tmp.push_back((*vec_1)[a]);
            a += 2;
        }
        else {
            tmp.push_back((*vec_2)[b]);
            b += 2;
        }
    }

    if (a >= size_1) {
        for (size_t j = b; j < size_2; j += 2) {
            tmp.push_back((*vec_2)[j]);
        }
    }
    else {
        for (size_t j = a; j < size_1; j += 2) {
            tmp.push_back((*vec_1)[j]);
        }
    }

    if (check)
        a = 0, b = 0;
    else
        a = 1, b = 1;

    size_t i = 0;

    while (a < size_1) {
        (*vec_1)[a] = tmp[i];
        a += 2;
        i++;
    }

    while (b < size_2) {
        (*vec_2)[b] = tmp[i];
        b += 2;
        i++;
    }
}

std::vector<double> simpleComparator(std::vector<double>* vec_1,
    std::vector<double>* vec_2) {
    size_t size_1 = vec_1->size(), size_2 = vec_2->size();
    std::vector<double> result(size_1 + size_2);
    size_t j = 0;
    for (size_t i = 0; i < size_1 - 1; i++) {
        if ((*vec_1)[i] > (*vec_1)[i + 1]) {
            std::swap((*vec_1)[i], (*vec_1)[i + 1]);
        }
        result[j++] = (*vec_1)[i];
    }
    result[j++] = (*vec_1)[size_1 - 1];

    if ((*vec_1)[size_1 - 1] > (*vec_2)[0]) {
        result[j - 1] = (*vec_2)[0];
        (*vec_2)[0] = (*vec_1)[size_1 - 1];
    }
    for (size_t i = 0; i < size_2 - 1; i++) {
        if ((*vec_2)[i] > (*vec_2)[i + 1]) {
            std::swap((*vec_2)[i], (*vec_2)[i + 1]);
        }
        result[j++] = (*vec_2)[i];
    }
    result[j] = (*vec_2)[size_2 - 1];

    return result;
}

std::vector<double> batcherMerge(std::vector<double>* vec_1,
    std::vector<double>* vec_2) {
    evenOrOddSplitter(vec_1, vec_2, true);
    evenOrOddSplitter(vec_1, vec_2, false);
    return simpleComparator(vec_1, vec_2);
}

std::vector<double> parallelRadixSort(std::vector<double>* vec, int size) {
    int number_threads = std::thread::hardware_concurrency();
    int local_size = size / number_threads;
    int remainder = size % number_threads;
    std::vector<std::vector<double>> data(number_threads);
    data[0] = { vec->begin(), vec->begin() + local_size + remainder };
    for (int i = 1; i < number_threads; i++) {
        data[i] = { vec->begin() + local_size * i + remainder,
                   vec->begin() + local_size * (i + 1) + remainder };
    }

    std::thread* threads = new std::thread[number_threads];
    for (int i = 0; i < number_threads; i++) {
        threads[i] = std::thread(radixSort, &data[i]);
        threads[i].join();
    }

    for (int i = 1; i < number_threads; i++) {
        data[0] = batcherMerge(&data[0], &data[i]);
    }

    delete[] threads;

    return data[0];
}
\end{lstlisting}

\par 12. Реализация на std::thread. Файл: main.cpp

\begin{lstlisting}[language=C++]
// Copyright 2022 Kraev Nikita
#include <gtest/gtest.h>
#include "../../../3rdparty/unapproved/unapproved.h"
#include "./radix_sort_with_even_odd_merge_std.h"

TEST(Parallel_Sort, Test_Radix_Sort_1) {
    std::vector<double> vec = { 1.0, -6.2, 7.45, -22.3457, 0.0, 45.69876, -0.03, 0.1 };
    std::vector<double> sort_vec = { -22.3457, -6.2, -0.03, 0.0, 0.1, 1.0, 7.45, 45.69876 };
    int size = 8;
    vec = parallelRadixSort(&vec, size);
    ASSERT_EQ(sort_vec, vec);
}

TEST(Parallel_Sort, Test_Radix_Sort_2) {
    int size = 100;
    std::vector<double> vec = getRandomVector(size);
    std::vector<double> std_sort_vec = vec;
    std::sort(std_sort_vec.begin(), std_sort_vec.end());
    vec = parallelRadixSort(&vec, size);
    ASSERT_EQ(std_sort_vec, vec);
}

TEST(Parallel_Sort, Test_Radix_Sort_3) {
    int size = 100000;
    std::vector<double> vec = getRandomVector(size);
    std::vector<double> seq_vec = vec;
    double begin_1 = omp_get_wtime();
    radixSort(&seq_vec);
    double end_1 = omp_get_wtime();
    double time_1 = end_1 - begin_1;
    std::cout << time_1 << std::endl;
    double begin_2 = omp_get_wtime();
    vec = parallelRadixSort(&vec, size);
    double end_2 = omp_get_wtime();
    double time_2 = end_2 - begin_2;
    std::cout << time_2 << std::endl;
    std::cout << "Boost:" << time_1 / time_2 << std::endl;
    ASSERT_EQ(seq_vec, vec);
}

TEST(Parallel_Sort, Test_Radix_Sort_4) {
    int size = 500000;
    std::vector<double> vec = getRandomVector(size);
    std::vector<double> seq_vec = vec;
    double begin_1 = omp_get_wtime();
    radixSort(&seq_vec);
    double end_1 = omp_get_wtime();
    double time_1 = end_1 - begin_1;
    std::cout << time_1 << std::endl;
    double begin_2 = omp_get_wtime();
    vec = parallelRadixSort(&vec, size);
    double end_2 = omp_get_wtime();
    double time_2 = end_2 - begin_2;
    std::cout << time_2 << std::endl;
    std::cout << "Boost:" << time_1 / time_2 << std::endl;
    ASSERT_EQ(seq_vec, vec);
}

TEST(Parallel_Sort, Test_Radix_Sort_5) {
    int size = 1000000;
    std::vector<double> vec = getRandomVector(size);
    std::vector<double> seq_vec = vec;
    double begin_1 = omp_get_wtime();
    radixSort(&seq_vec);
    double end_1 = omp_get_wtime();
    double time_1 = end_1 - begin_1;
    std::cout << time_1 << std::endl;
    double begin_2 = omp_get_wtime();
    vec = parallelRadixSort(&vec, size);
    double end_2 = omp_get_wtime();
    double time_2 = end_2 - begin_2;
    std::cout << time_2 << std::endl;
    std::cout << "Boost:" << time_1 / time_2 << std::endl;
    ASSERT_EQ(seq_vec, vec);
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
\end{lstlisting}

\end{document}
